# 汇编语言（王爽）检测点参考答案

## 1.1

（1）13

> 解析：CPU在内存中寻址的最小单位是Byte（字节），8KB = 2^13B，因此地址总线的宽度为13

（2）1024；0 1023

> 解析：一个存储单元能存储的信息为8个bit（比特）也就是1Byte（简写B）(字节)，1KB=1024B，所以为1024个存储单元；因为每个存储单元从0开始顺序编号

（3）8192；1024

> 解析：一个存储单元能存储的信息为8个bit（比特），1KB的存储器有1024个存储单元，所以可以存储1024*8=8192个bit；8个bit=1Byte，所以为1024个Byte

（4）1,073,741,824；1,048,576；1,024；

> 解析：1KB=1024B 1MB=1024KB 1GB=1024MB

（5）64；1；16；4；

> 解析：CPU在内存中寻址的最小单位是Byte（字节）, 2^16B=64KB；2^20B=1MB；2^24B=16MB；2^32B=4GB

（6）1；1；2；2；4；

> 解析：8根数据总线一次可以传送一个8位二级制数据（即一个字节）

（7）512；256

> 解析：8086一次可以读取2个字节1024/2=512；80386一次可以传送4个字节1024/4=256

（8）二进制

## 2.1

(1)

mov ax,62627 AX=F4A3H | 62627

> 解析：将62627送入寄存器AX；所以AX为"62627"，为了直观也可以转为16进制"F4A3H"

mov ah,31H AX=31A3H

> 解析：将31H送入寄存器AH，此时的AH=31H，由上文所知AL=A3H；所以AX=31A3H

mov al,23H AX=3123H

> 解析：将23H送入寄存器AL，此时的AL=23H，由上文所知AH=31H；所以AX=3123H

add ax,ax AX=6246H

> 解析：将寄存器AX中的数值加上AX，由上文所知AX=3123H；经计算得AX=6246H

mov bx,826CH BX=826CH

> 解析：将826CH送入寄存器BX；所以BX为826CH

mov cx,ax CX=6246H

> 解析：将寄存器AX中的数据送入寄存器CX，由上文所知AX=6246H；所以CX为6246H

mov ax,bx AX=826CH

> 解析：将寄存器BX中的数据送入寄存器AX，由上文所知BX=826CH；所以AX为826CH

add ax,bx AX=04D8H

> 解析：将寄存器BX中的数据与寄存器AX中的数据相加，结果存在AX中；由上文所知AX=826CH，BX=826CH；相加后的值为104D8H，但是AX为16位寄存器，只能存放4位十六进制的数据，所以最高位的1不能存在AX中；所以AX为04D8H

mov al,bh AX=0482H

> 解析：将寄存器BH的数值送入寄存器AL；由上文可知BH为82H，AH为04H；所以AX为0482H

mov ah,bl AX=6C82H

> 解析：将寄存器BL的数值送入寄存器AH；由上文可知BL为6CH，AL为82H；所以AX为6C82H

add ah,ah AX=D882H

> 解析：将寄存器AH中的数据与寄存器AH中的数据相加，相加后AH为D8H，由上文可知AL为82H；所以AX为D882H

add al,6 AX=D888H

> 解析：将寄存器AL中的数据加上6，由上文可知AH为D8H、AL为82H，AL相加后的值为88H；所以AX为D888H

add al,al AX=D810H

> 解析：将寄存器AL中的数据与寄存器AL中的数据相加；由上文所知AL=88H，AH=D8H；相加后的值为110H，但是AL为8位寄存器，只能存放2位十六进制的数据，所以最高位的1不能存在AL中；AL为10H，所以AX为D810H

mov ax,cx AX=6246H

> 解析：将寄存器CX的数值送入寄存器AX；由上文可知CX为6246H；所以AX为6246H

（2）

mov ax,2   ->  AX=2
add ax,ax  ->  AX=4
add ax,ax  ->  AX=8
add ax,ax  ->  AX=16

## 2.2

(1) 00010H；1000FH

> 解析：根据8086CPU的寻址模式“段地址x16+偏移地址=物理地址”，设偏移地址为EA、物理地址为X，可得：0001Hx16+EA=X；由于EA的变化范围为0\~FFFFH；经过计算得X的范围为00010H\~1000FH

（2）1001H；2000H

> 解析：根据8086CPU的寻址模式“段地址x16+偏移地址=物理地址”，设偏移地址为EA；已知EA范围为0\~FFFFH、物理地址为20000H；经过计算得段地址SA的范围为1001H\~2000H

## 2.3

CPU4次修改IP:

1.将`mov ax,bx`指令读取入指令缓冲器

2.将`sub ax,ax`读取入指令缓冲器

3.将`jmp ax`读取入指令缓冲器

4.`jmp ax`指令被执行后

最后IP值为`ax`

## 3.1

（1）

mov ax,[0000] AX=2662H

> 解析："mov 寄存器，内存单元"；因为DS=1，IP=0，所以物理地址为0010H(0000:0010)；可知高8位为26H，低8位为62H，可得AX的值为2662H

mov bx,[0001] BX=E626H

> 解析："mov 寄存器，内存单元"；因为DS=1，IP=1，所以物理地址为0011H(0000:0011)；可知高8位为E6H，低8位为26H，可得BX的值为E626H

mov ax,bx AX=E626H

> 解析：将寄存器BX中的数据送入寄存器AX，由上文所知BX=E626H；所以AX为E626H

mov ax,[0000] AX=2662H

> 解析："mov 寄存器，内存单元"；因为DS=1，IP=0，所以物理地址为0010H(0000:0010)；可知高8位为26H，低8位为62H，可得AX的值为2662H

mov bx,[0002] BX=D6E6H

> 解析："mov 寄存器，内存单元"；因为DS=1，IP=2，所以物理地址为0012H(0000:0012)；可知高8位为D6H，低8位为E6H，可得AX的值为D6E6H

add ax,bx AX=FD48H

> 解析：将寄存器BX中的数据与寄存器AX中的数据相加，结果存在AX中；由上文所知AX=2662H，BX=D6E6H；相加后的值为FD48H；所以AX为FD48H

add ax,[0004] AX=2C14H

> 解析："add 寄存器，内存单元"；因为DS=1，IP=4，所以物理地址为0014H(0000:0014)；可知高8位为2EH，低8位为CCH，所以当前内存单元的值为2ECCH，由上文可知AX=FD48H，相加后的值为12C14H，但是AX为16位寄存器，只能存放4位十六进制的数据，所以最高位的1不能存在AX中；所以AX为2C14H

mov ax,0 AX=0

> 解析：将0送入寄存器AX；所以AX为0

mov al,[0002] AX=00E6H

> 解析："mov 寄存器，内存单元"；因为DS=1，IP=2，所以物理地址为0012H(0000:0012)；可知低8位为E6H，将值E6H送入寄存器AL，由上文可知AH=0，所以AX的值为00E6H

mov bx,0 BX=0

> 解析：将0送入寄存器BX；所以BX为0

mov bl,[000C] BX=0026H

> 解析："mov 寄存器，内存单元"；因为DS=1，IP=CH，所以物理地址为0022H(0000:0022)；可知低8位为26H，将值26H送入寄存器BL，由上文可知BH=0，所以BX的值为0026H

add al,bl AX=000CH

> 解析：将寄存器AL中的数据与寄存器BL中的数据相加；由上文所知AH=00H，AL=E6H，BL=26H；相加后的值为10CH，但是AL为8位寄存器，只能存放2位十六进制的数据，所以最高位的1不能存在AL中；AL为0CH，所以AX为000CH

（2）

|  指向的内存地址   |     执行的指令    |  CS   |  DS   |  IP   |  AX   |  BX   |
| - | - | - | - | - | - | - |
2000:0000(20000H) |  mov ax,6622H   | 2000H | 1000H | 0003H | 6622H |   0   | AX=6622H；IP=0003H
2000:0003(20003H) |  jmp 0ff0:0100  | 0ff0H | 1000H | 0100H | 6622H |   0   | CS=0ff0H；IP=0100H
0ff0:0100(10000H) |  mov ax,2000H   | 0ff0H | 1000H | 0103H | 2000H |   0   | AX=2000H；IP=0103H
0ff0:0103(10003H) |  mov ds,ax      | 0ff0H | 2000H | 0105H | 2000H |   0   | DS=2000H；IP=0105H
0ff0:0105(10005H) |  mov ax,[0008]  | 0ff0H | 2000H | 0108H | C389H |   0   | AX=C389H；IP=0108H
0ff0:0105(10008H) |  mov ax,[0002]  | 0ff0H | 2000H | 010BH | EA66H |   0   | AX=EA66H；IP=010BH
0ff0:010B(1000BH) |                 | 0ff0H | 2000H | 010BH | EA66H |   0   | AX=EA66H；IP=010BH

## 3.2

（1）

mov bx,2000H
mov ss,bx
mov sp,10H

（2）

mov bx,1000H
mov ss,bx
mov sp,0

## 6.1

（1）

mov cs:[bx],ax

（2）
cs
1Ah
pop cs:[bx]

## 参考

<https://blackdragonf.github.io/2017/03/05/王爽汇编语言第三版检测点答案>

<https://yq.aliyun.com/articles/646788/>
