<!-- markdownlint-disable MD033 MD037 -->
<!-- TODO 六大原则 -->
# 设计模式(Design Patterns)

## 什么是设计模式

设计模式是对软件设计开发过程中反复出现的某类问题的通用解决方案。学习设计模式更多的是理解各种模式的内在思想和解决的问题。

## 设计模式的三大类型

- 结构型模式（Structural Patterns）： 通过识别系统中组件间的简单关系来简化系统的设计。
- 创建型模式（Creational Patterns）： 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。
- 行为型模式（Behavioral Patterns）： 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。

| 结构型 | 创建型 | 行为型 |
| - | - | - |
| 适配器模式<br/>Adapter pattern | 建造者模式<br/>Builder pattern | 解释器模式<br/>Interpreter pattern |
| 桥接模式<br/>Bridge pattern | 单例模式<br/>Singleton pattern | 模板模式<br/>Template pattern |
| 过滤器模式<br/>Filter pattern | 原型模式<br/>Prototype pattern | 访问者模式<br/>Visitor pattern |
| 组合模式<br/>Composite pattern | 工厂模式<br/>Factory pattern | 策略模式<br/>Strategy pattern |
| 外观模式<br/>Facade pattern | 抽象工厂模式<br/>Abstract factory pattern | 状态模式<br/>State pattern |
| 装饰器模式<br/>Decorator pattern | - | 观察者模式<br/>Observer pattern |
| 代理模式<br/>Proxy pattern | - | 备忘录模式<br/>Memento pattern |
| 享元模式<br/>Flyweight pattern | - | 迭代器模式<br/>Iterator pattern |
| - | - | 命令模式<br/>Command pattern |
| - | - | 中介者模式<br/>Mediator pattern |
| - | - | 责任链模式<br/>Chain of responsibility pattern |

### 外观模式

描述：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，通过这个接口使得这一个子系统更加容易使用。

目的：从外部的角度来看，由一对多，变成一对一。简化外部使用系统。

<!-- - 降低耦合度
- 封装交互
- 简化调用 -->

优点：

- 简化系统的使用，不用再通过多个子系统。
- 降低了子系统与外部的耦合度。

缺点：

<!-- - 不能很好地限制外部使用子系统。 -->

例子：

- JQuery 通过外观模式兼容了浏览器间的差异，简化了调用；代码与各浏览器解耦。

通过下图理解，“系统”，“子系统”和“外部”

![房产局办理房产证](https://oss.taichiyi.com/markdown/otgxya8n.png)

上图中房产局就是一个“系统”，系统外的叫做“外部”，所以图中的客户可以被称为“外部”，房产局中的多个窗口就相当于“子系统”。

延伸：

-

### 代理模式

描述：代理目标对象。

目的：

- 对目标对象的特定操作进行访问控制。

优点：

- 降低外部与目标对象的耦合度
- 高扩展性

缺点：

- 增加了访问目标对象的复杂度

例子：

- Vue.js 的双向绑定

延伸：

- 静态代理和动态代理是按照代理创建的时期来划分的，编译时创建的为静态，运行时创建的为动态。

### 工厂模式

描述：使用多个简单的对象一步一步构建成一个复杂的对象。

目的：

- 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

优点：

- 建造者相互独立，有利于系统的扩展
- 外部不必知道内部组成的细节，便于控制细节风险。

缺点：

- 

例子：

- Vue.js 的双向绑定

延伸：

- 静态代理和动态代理是按照代理创建的时期来划分的，编译时创建的为静态，运行时创建的为动态。
